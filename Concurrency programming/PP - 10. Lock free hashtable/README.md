# Lock-free hashtable

[![Build Status](https://travis-ci.com/ITMO-MPP-2017/lock-free-hashtable-Shemplo.svg?token=B2yLGFz6qwxKVjbLm9Ak&branch=master)](https://travis-ci.com/ITMO-MPP-2017/lock-free-hashtable-Shemplo)

## Описание
Проект включает в себя следующие исходные файлы:

* `IntIntHashMap.java` содержит реализацию хеш-таблицы с открытой адресацией для однопоточного случая;
* `pom.xml` содержит описание проекта для системы сборки Maven.

## Задание
Необходимо доработать реализую `IntIntHashMap` так, чтобы она использовала синхронизацию без блокировок (lock-free). Для реализации воспользуйтесь алгоритмом, представленным в [этой статье](https://arxiv.org/pdf/cs/0303011.pdf). Данный алгоритм был рассказан в рамках лекции №11. Параграф 4.3 в статье соответствует материалу лекции. 

### Подробности
1.	Общий дизайн кода, названия классов и набор публичных методов должны быть оставлены без изменения.
2.	Изначальный размер таблицы (значение поля `INITIAL_CAPACITY`) должен остаться без изменения. Это требуется для корректного тестирования.
3.	Приведенная реализация `IntIntHashMap` имеет один существенный недостаток. Размер таблицы всегда увеличивается в два раза, даже если она была заполнена удаленными элементами. Реальный размер таблицы не проверяется при выборе нового размера в операции **rehash**. Вам не требуется исправлять этот недостаток.
4.	В классе `IntIntHashMap.Core` замените `int[] map` на `AtomicIntegerArray map`, чтобы вы могли делать над элементами массива операции `map.compareAndSet`.
5.	В классе `IntIntHashMap.Core` добавьте переменную `AtomicReference<Сore> next`, которая будет содержать указатель на ядро таблицы большего размера в том случае, когда было начато копирование старой таблицы в новую. Потокам, которые одновременно столкнулись с ситуацией `NEEDS_REHASH`, необходимо прийти к консенсусу относительно указателя на новую таблицу с помощью операции `next.compareAndSet`.
6.	Класс `IntIntHashMap` поддерживает только положительные ключи и значения, строго меньшие `Integer.MAX_VALUE`. Используйте старшие биты и значение `Integer.MAX_VALUE`, чтобы помечать значения согласно нуждам алгоритма:
    * Новая ячейкабудет представлена значением ноль.
    * `V'` в нотации лекции или `old(V)` в нотации статьи будет представлено путем выставления старшего бита. 
    * `T` в нотации лекции или `del` в нотации статьи будет представлено значением `Integer.MAX_VALUE`.
    * `S` в нотации лекции или done в нотации статьи будет представлено значением `Integer.MIN_VALUE`.
7.	Вам не нужно думать об освобождении памяти. Об этом позаботится GC. Поэтому, те части алгоритма, где идет рассказ об отслеживании работающих потоков и т.п., вы можете смело пропускать. 

Реализовывать по-настоящему кооперативную операцию rehash необязательно, хотя это и очень важно на практике. Для выполнения данного задания допустима реализация, как описано в статье, в которой rehash начинают и заканчивают те потоки, которые натолкнулись на необходимость его делать, получив результат `NEEDS_REHASH`. Однако, даже те потоки, которые не столкнулись с ситуацией `NEEDS_REHASH`, могут обнаружить, что элементы таблицы, которые они читают или хотят поменять, находятся в процессе переноса или уже перенесены в новую, и должны уметь обрабатывать эту ситуацию без блокировки, помогая завершить незаконченное копирование и повторяя свою операцию в новой таблице.

## Сборка и тестирование
Для тестирования используйте команду `mvn test`. При этом автоматически будут запущены следующие тесты:

* `FunctionalTest.java` проверяет базовую корректность множества.
* `LinearizabilityTest.java` проверяет реализацию множества на корректность в многопоточной среде.

Обратите внимание, что тесты не покрывают все возможные ошибки синхронизации, поэтому прохождение тестов не означает корректность реализации.

## Формат сдачи

Выполняйте задание в этом репозитории. По готовности добавьте "+" в таблицу с оценками в столбец "Готово" текущего задания. 

В случае необходимости доработки домашнего задания после проверки, "+" в таблице замененяется на "?" и создается issue на GitHub-е. Как только необходимые исправления произведены, заменяйте "?" обратно на "+" и закрывайте issue. После этого задание будет проверено ещё раз.

Перед сдачей задания замените `<your_GitHub_account>` в начале данного файла на свой логин в GitHub для получения информации о сборке в Travis. Это нужно сделать в двух местах: ссылка на картинку и на билд в Travis-е.

## Оценки и лекции
Таблица с оценками доступна тут: [https://goo.gl/YZrm9Z]()

Лекции доступны на Google Drive: [https://goo.gl/VjKtdK]()
